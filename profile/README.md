# 📘 Lernjournal – Reflexion & Gesamtfazit

## 1.1 💻 Umgebung Hardware/Software

Für die Bearbeitung und Umsetzung der DevOps-Module nutzte ich ein Surface Laptop der 5. Generation, auf dem das Betriebssystem **Windows 10 Pro (64-Bit, Version 22H2)** installiert ist.  

Der Laptop verfügt über einen **Intel Core i5-7300U Prozessor** mit einer Basistaktfrequenz von 2.60 GHz und einer maximalen Taktfrequenz von 2.71 GHz. Zusätzlich ist das Gerät mit **8 GB RAM** ausgestattet, was für alltägliche Software-Entwicklung, paralleles Arbeiten in mehreren Tools sowie für den Einsatz von **Build- und Testprozessen in Jenkins oder Docker** ausreichend war.  

Ein weiterer Vorteil dieses Systems ist die Unterstützung von **Stift- und Touchbedienung** mit bis zu zehn Eingabepunkten, was die Bedienbarkeit erhöht. Auch visuelle Tools wie VS Code oder Git GUIs konnten problemlos eingesetzt werden.  
Insgesamt war die technische Umgebung stabil, performant und für die Kursinhalte bestens geeignet.

---

## 1.2 👤 Person, Motivation & Bezug zu DevOps

Mein Name ist **Alessio Pugliese**, und die Teilnahme an diesem Kurs war für mich eine besonders spannende Reise durch ein bislang technisch kaum erschlossenes Gebiet. Ich komme ursprünglich aus der **unternehmerischen Praxis** und bin seit mehreren Jahren im Bereich der **Entwicklung skalierbarer Geschäftsmodelle** tätig. Dabei liegt mein Fokus vor allem auf der konzeptionellen Ebene: Wie können digitale Geschäftsprozesse effizient gestaltet, innovative Lösungen entwickelt und IT-Lösungen strategisch sinnvoll in Unternehmen integriert werden?

Während ich mit der Struktur und den Möglichkeiten von IT-Systemen vertraut bin, hatte ich bislang **kaum direkten Kontakt mit konkreten Entwicklungs- oder DevOps-Prozessen**. Begriffe wie Git, CI/CD, Jenkins, Docker oder Testautomatisierung kannte ich zwar theoretisch, aber mir fehlte das praktische Know-how, um deren Bedeutung im Entwicklungsprozess wirklich zu verstehen oder gar selbst anzuwenden.

Genau hier setzte dieser Kurs an – und wurde für mich zu einer echten Entdeckungsreise. Ich konnte die **DevOps-Welt nicht nur aus der Ferne beobachten**, sondern sie **selbst aktiv erleben und anwenden**. Die Übungen führten mich Schritt für Schritt durch die zentralen Stationen moderner Softwareentwicklung:
- von der **Versionierung mit Git und GitHub**,
- über die **automatisierte Qualitätssicherung mit JUnit und SonarQube**,
- bis hin zur **Konfiguration vollständiger CI/CD-Pipelines mit Jenkins, Docker und Cloud Deployment über GitHub Actions**.

Dabei habe ich nicht nur technische Tools kennengelernt, sondern auch ein neues **Verständnis für den Entwicklungsprozess als Ganzes** entwickelt. Ich habe gelernt, wie wichtig stabile Build-Prozesse, durchdachte Automatisierungen und kontinuierliches Testing sind, um **verlässliche und skalierbare Softwareprodukte** zu bauen. Besonders beeindruckt hat mich, wie stark einzelne Schritte verzahnt sind – und wie viel Planung, Standardisierung und Präzision es braucht, um eine moderne DevOps-Kette am Laufen zu halten.

Aus meiner Perspektive als **Strategieberater** war es besonders aufschlussreich zu sehen, **wie tief technische Entscheidungen in wirtschaftlichen Erfolg einzahlen**: Wenn Deployment-Prozesse reibungslos ablaufen, Tests automatisiert sind und Versionen sauber verwaltet werden, entstehen weniger Fehler, schnellere Feedback-Zyklen – und letztlich bessere Produkte.

Kurzum:  
Ich habe **DevOps nicht nur verstanden, sondern erlebt**. Und obwohl mein Hintergrund kein klassischer Tech-Background ist, konnte ich alle Themen nachvollziehen und praktisch umsetzen – und habe dadurch ein **tiefes technisches Verständnis für ein Feld gewonnen, das für digitale Geschäftsmodelle heute unerlässlich ist**.

## 1.3 🧭 Gesamtfazit zur Reise durch alle Module

Der Kurs bot einen hervorragenden Überblick und eine strukturierte, praxisorientierte Einführung in alle zentralen DevOps-Themen.  
Von der ersten Versionierung über automatisierte Tests bis hin zum Cloud-Deployment wurde der gesamte **Software Lifecycle in Modulen abgebildet**, wodurch die Inhalte sehr greifbar wurden.

Besonders hilfreich war die **Verknüpfung von Theorie und Praxis**: Jede Lektion baute logisch auf der vorherigen auf, wodurch ich nicht nur isolierte Tools kennengelernt habe, sondern **die Zusammenhänge und Abhängigkeiten innerhalb moderner Entwicklungsprozesse** verstehen konnte.

Ich weiss jetzt, wie man:
- ein Repository sinnvoll strukturiert und versioniert,
- Codequalität durch Unit-Tests, Coverage und SonarQube sicherstellt,
- Jenkins für Build- und Deployment-Prozesse einsetzt,
- Docker für reproduzierbare Umgebungen verwendet,
- und GitHub Actions für Deployment Workflows in die Cloud nutzt.

Besonders die abschliessenden Module zum Thema **CI/CD und Containerisierung** haben mir geholfen, die Komplexität von Softwareauslieferung zu durchdringen und die Automatisierung als echten Hebel für Qualität und Effizienz zu begreifen.

Ich fühle mich nun deutlich sicherer im Umgang mit DevOps-Werkzeugen – und sehe in ihnen **nicht nur Tools, sondern eine Denkweise**, die sich hervorragend auf viele Bereiche der digitalen Transformation anwenden lässt.

---

## 1.4 👥 Peer Feedback – Adrian Hitz

### 👤 Allgemeine Informationen

- **Name:** Adrian Hitz  
- **GitHub-Repository:** [DevOps-07-CI](https://github.com/hitzad/DevOps-07-CI)  
- **Präsentiertes Thema:** *Continuous Integration (CI)*  

Adrian hat im Rahmen des DevOps-Kurses das Thema **Continuous Integration** bearbeitet und seine Resultate in einer **Live-Demo** präsentiert. Anstelle klassischer Präsentationsfolien setzte er konsequent auf die praktische Umsetzung innerhalb einer realen Umgebung – ein mutiger und zugleich sehr wirkungsvoller Ansatz.

---

### 🧩 Aufbau & Struktur der Präsentation

Adrian entschied sich für eine **Live-Demonstration direkt im Entwicklungs- und Build-Setup**, was dem Vortrag eine hohe Authentizität und Praxisnähe verlieh.  
Obwohl er bewusst auf eine vorbereitete Slideshow verzichtete, war der Vortrag **stringent aufgebaut und logisch gegliedert**. Die Präsentation bestand aus mehreren klar unterscheidbaren Abschnitten:

1. **Einführung in das Thema Continuous Integration**  
   Er begann mit einer kurzen mündlichen Einführung in das CI-Prinzip – darunter die wichtigsten Ziele (frühes Feedback, automatisierte Builds, Qualitätssicherung).  
   Dabei spannte er geschickt den Bogen zu den späteren Praxisbeispielen, was half, die Bedeutung von CI konzeptionell zu erfassen.

2. **Vorstellung des technischen Setups**  
   Adrian erläuterte die eingesetzten Tools, darunter insbesondere:
   - GitHub als Quellcodeverwaltung,
   - Jenkins als Build-Server,
   - Docker zur Containerisierung und
   - ein CI-spezifisches Jenkinsfile zur Automatisierung der Pipeline.  
   Die zugrunde liegende Struktur seines Projekts war gut organisiert und sauber dokumentiert.

3. **Live-Demonstration der Pipeline**  
   Im Kern des Vortrags zeigte Adrian live den Ablauf eines automatisierten Builds, von der Änderung im Code über den Push ins Repository bis hin zum ausgelösten Jenkins-Build.  
   Besonders gelungen war, wie er dabei auf potenzielle Fehlerszenarien einging und aufzeigte, wie Jenkins Feedback zu fehlschlagenden Tests oder Build-Konflikten liefert.

4. **Zusammenfassungen nach jedem Abschnitt**  
   Nach jedem Demonstrationsschritt folgte eine prägnante Zusammenfassung. Dadurch ermöglichte Adrian es auch weniger erfahrenen Kommiliton:innen, den roten Faden nicht zu verlieren.  
   Diese Zwischenschritte trugen stark zum Lernerfolg bei.

---

### 🔍 Fachliche Tiefe & technische Umsetzung

Adrians Vortrag zeichnete sich durch **technische Präzision und Praxisnähe** aus. Die eingesetzten Tools wurden nicht nur korrekt konfiguriert, sondern im Zusammenspiel vorgeführt.  
Er zeigte unter anderem:
- das saubere Triggern der CI-Pipeline nach einem GitHub-Push,
- die Einbindung automatisierter Tests zur Qualitätskontrolle,
- und die Verifizierung der Codequalität mit SonarQube (optional erwähnt).  

Zudem erklärte er gut verständlich, wie **Jenkinsfile-Strukturen** aufgebaut sind, wie die einzelnen Stages (Build, Test, Analyse) ineinandergreifen und wie **Ergebnisse interpretiert** werden.  
Es war erkennbar, dass er sich intensiv mit der Thematik auseinandergesetzt und verschiedene Testläufe im Vorfeld durchgeführt hatte.

---

### 🧠 Didaktik & Präsentationstechnik

Obwohl Adrian ohne Präsentationsfolien arbeitete, war sein Vortrag **klar, ruhig und souverän**.  
Besonders hervorzuheben ist seine Fähigkeit, **komplexe Abläufe verbal so zu vermitteln, dass auch Nicht-Tech-Expert:innen folgen konnten**.

Er sprach frei, variierte Tempo und Stimme passend zum Inhalt und bezog das Publikum immer wieder mit rhetorischen Fragen ein („Was passiert jetzt im Hintergrund?“, „Woran erkennt man, ob der Build erfolgreich war?“).  
Seine **Zusammenfassungen nach jedem Abschnitt** sowie seine **präzisen Live-Erläuterungen** machten den Vortrag didaktisch sehr hochwertig.

---

### ⭐ Persönlicher Eindruck & Fazit

Ich war ehrlich gesagt **positiv überrascht**, da ich anfangs etwas skeptisch war, als keine klassische Präsentation angekündigt wurde. Doch Adrian hat es geschafft, durch eine **konsequent praxisorientierte Live-Demo**, die Erwartungen weit zu übertreffen.

Er kombinierte **technisches Können mit einem didaktisch wertvollen Vortragsstil**, vermittelte Inhalte verständlich und spannend und zeigte sich in der Fragerunde souverän.  
Auch bei potenziellen Fehlerquellen blieb er ruhig und konnte mögliche Stolpersteine erklären – das zeugt von echter Sicherheit in der Materie.

**Fazit:**  
Adrian hat eine der besten Präsentationen des Kurses gehalten – mit hohem fachlichem Anspruch, sehr guter Struktur und einer angenehmen, klaren Kommunikation. **Chapeau – wirklich stark!**

---


---
