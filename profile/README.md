# ğŸ“˜ Lernjournal â€“ Reflexion & Gesamtfazit

## 1.1 ğŸ’» Umgebung Hardware/Software

FÃ¼r die Bearbeitung und Umsetzung der DevOps-Module nutzte ich ein Surface Laptop der 5. Generation, auf dem das Betriebssystem **Windows 10 Pro (64-Bit, Version 22H2)** installiert ist.  

Der Laptop verfÃ¼gt Ã¼ber einen **Intel Core i5-7300U Prozessor** mit einer Basistaktfrequenz von 2.60â€¯GHz und einer maximalen Taktfrequenz von 2.71â€¯GHz. ZusÃ¤tzlich ist das GerÃ¤t mit **8â€¯GB RAM** ausgestattet, was fÃ¼r alltÃ¤gliche Software-Entwicklung, paralleles Arbeiten in mehreren Tools sowie fÃ¼r den Einsatz von **Build- und Testprozessen in Jenkins oder Docker** ausreichend war.  

Ein weiterer Vorteil dieses Systems ist die UnterstÃ¼tzung von **Stift- und Touchbedienung** mit bis zu zehn Eingabepunkten, was die Bedienbarkeit erhÃ¶ht. Auch visuelle Tools wie VS Code oder Git GUIs konnten problemlos eingesetzt werden.  
Insgesamt war die technische Umgebung stabil, performant und fÃ¼r die Kursinhalte bestens geeignet.

---

## 1.2 ğŸ‘¤ Person, Motivation & Bezug zu DevOps

Mein Name ist **Alessio Pugliese**, und die Teilnahme an diesem Kurs war fÃ¼r mich eine besonders spannende Reise durch ein bislang technisch kaum erschlossenes Gebiet. Ich komme ursprÃ¼nglich aus der **unternehmerischen Praxis** und bin seit mehreren Jahren im Bereich der **Entwicklung skalierbarer GeschÃ¤ftsmodelle** tÃ¤tig. Dabei liegt mein Fokus vor allem auf der konzeptionellen Ebene: Wie kÃ¶nnen digitale GeschÃ¤ftsprozesse effizient gestaltet, innovative LÃ¶sungen entwickelt und IT-LÃ¶sungen strategisch sinnvoll in Unternehmen integriert werden?

WÃ¤hrend ich mit der Struktur und den MÃ¶glichkeiten von IT-Systemen vertraut bin, hatte ich bislang **kaum direkten Kontakt mit konkreten Entwicklungs- oder DevOps-Prozessen**. Begriffe wie Git, CI/CD, Jenkins, Docker oder Testautomatisierung kannte ich zwar theoretisch, aber mir fehlte das praktische Know-how, um deren Bedeutung im Entwicklungsprozess wirklich zu verstehen oder gar selbst anzuwenden.

Genau hier setzte dieser Kurs an â€“ und wurde fÃ¼r mich zu einer echten Entdeckungsreise. Ich konnte die **DevOps-Welt nicht nur aus der Ferne beobachten**, sondern sie **selbst aktiv erleben und anwenden**. Die Ãœbungen fÃ¼hrten mich Schritt fÃ¼r Schritt durch die zentralen Stationen moderner Softwareentwicklung:
- von der **Versionierung mit Git und GitHub**,
- Ã¼ber die **automatisierte QualitÃ¤tssicherung mit JUnit und SonarQube**,
- bis hin zur **Konfiguration vollstÃ¤ndiger CI/CD-Pipelines mit Jenkins, Docker und Cloud Deployment Ã¼ber GitHub Actions**.

Dabei habe ich nicht nur technische Tools kennengelernt, sondern auch ein neues **VerstÃ¤ndnis fÃ¼r den Entwicklungsprozess als Ganzes** entwickelt. Ich habe gelernt, wie wichtig stabile Build-Prozesse, durchdachte Automatisierungen und kontinuierliches Testing sind, um **verlÃ¤ssliche und skalierbare Softwareprodukte** zu bauen. Besonders beeindruckt hat mich, wie stark einzelne Schritte verzahnt sind â€“ und wie viel Planung, Standardisierung und PrÃ¤zision es braucht, um eine moderne DevOps-Kette am Laufen zu halten.

Aus meiner Perspektive als **Strategieberater** war es besonders aufschlussreich zu sehen, **wie tief technische Entscheidungen in wirtschaftlichen Erfolg einzahlen**: Wenn Deployment-Prozesse reibungslos ablaufen, Tests automatisiert sind und Versionen sauber verwaltet werden, entstehen weniger Fehler, schnellere Feedback-Zyklen â€“ und letztlich bessere Produkte.

Kurzum:  
Ich habe **DevOps nicht nur verstanden, sondern erlebt**. Und obwohl mein Hintergrund kein klassischer Tech-Background ist, konnte ich alle Themen nachvollziehen und praktisch umsetzen â€“ und habe dadurch ein **tiefes technisches VerstÃ¤ndnis fÃ¼r ein Feld gewonnen, das fÃ¼r digitale GeschÃ¤ftsmodelle heute unerlÃ¤sslich ist**.

## 1.3 ğŸ§­ Gesamtfazit zur Reise durch alle Module

Der Kurs bot einen hervorragenden Ãœberblick und eine strukturierte, praxisorientierte EinfÃ¼hrung in alle zentralen DevOps-Themen.  
Von der ersten Versionierung Ã¼ber automatisierte Tests bis hin zum Cloud-Deployment wurde der gesamte **Software Lifecycle in Modulen abgebildet**, wodurch die Inhalte sehr greifbar wurden.

Besonders hilfreich war die **VerknÃ¼pfung von Theorie und Praxis**: Jede Lektion baute logisch auf der vorherigen auf, wodurch ich nicht nur isolierte Tools kennengelernt habe, sondern **die ZusammenhÃ¤nge und AbhÃ¤ngigkeiten innerhalb moderner Entwicklungsprozesse** verstehen konnte.

Ich weiss jetzt, wie man:
- ein Repository sinnvoll strukturiert und versioniert,
- CodequalitÃ¤t durch Unit-Tests, Coverage und SonarQube sicherstellt,
- Jenkins fÃ¼r Build- und Deployment-Prozesse einsetzt,
- Docker fÃ¼r reproduzierbare Umgebungen verwendet,
- und GitHub Actions fÃ¼r Deployment Workflows in die Cloud nutzt.

Besonders die abschliessenden Module zum Thema **CI/CD und Containerisierung** haben mir geholfen, die KomplexitÃ¤t von Softwareauslieferung zu durchdringen und die Automatisierung als echten Hebel fÃ¼r QualitÃ¤t und Effizienz zu begreifen.

Ich fÃ¼hle mich nun deutlich sicherer im Umgang mit DevOps-Werkzeugen â€“ und sehe in ihnen **nicht nur Tools, sondern eine Denkweise**, die sich hervorragend auf viele Bereiche der digitalen Transformation anwenden lÃ¤sst.

---

## 1.4 ğŸ‘¥ Peer Feedback â€“ Adrian Hitz

### ğŸ‘¤ Allgemeine Informationen

- **Name:** Adrian Hitz  
- **GitHub-Repository:** [DevOps-07-CI](https://github.com/hitzad/DevOps-07-CI)  
- **PrÃ¤sentiertes Thema:** *Continuous Integration (CI)*  

Adrian hat im Rahmen des DevOps-Kurses das Thema **Continuous Integration** bearbeitet und seine Resultate in einer **Live-Demo** prÃ¤sentiert. Anstelle klassischer PrÃ¤sentationsfolien setzte er konsequent auf die praktische Umsetzung innerhalb einer realen Umgebung â€“ ein mutiger und zugleich sehr wirkungsvoller Ansatz.

---

### ğŸ§© Aufbau & Struktur der PrÃ¤sentation

Adrian entschied sich fÃ¼r eine **Live-Demonstration direkt im Entwicklungs- und Build-Setup**, was dem Vortrag eine hohe AuthentizitÃ¤t und PraxisnÃ¤he verlieh.  
Obwohl er bewusst auf eine vorbereitete Slideshow verzichtete, war der Vortrag **stringent aufgebaut und logisch gegliedert**. Die PrÃ¤sentation bestand aus mehreren klar unterscheidbaren Abschnitten:

1. **EinfÃ¼hrung in das Thema Continuous Integration**  
   Er begann mit einer kurzen mÃ¼ndlichen EinfÃ¼hrung in das CI-Prinzip â€“ darunter die wichtigsten Ziele (frÃ¼hes Feedback, automatisierte Builds, QualitÃ¤tssicherung).  
   Dabei spannte er geschickt den Bogen zu den spÃ¤teren Praxisbeispielen, was half, die Bedeutung von CI konzeptionell zu erfassen.

2. **Vorstellung des technischen Setups**  
   Adrian erlÃ¤uterte die eingesetzten Tools, darunter insbesondere:
   - GitHub als Quellcodeverwaltung,
   - Jenkins als Build-Server,
   - Docker zur Containerisierung und
   - ein CI-spezifisches Jenkinsfile zur Automatisierung der Pipeline.  
   Die zugrunde liegende Struktur seines Projekts war gut organisiert und sauber dokumentiert.

3. **Live-Demonstration der Pipeline**  
   Im Kern des Vortrags zeigte Adrian live den Ablauf eines automatisierten Builds, von der Ã„nderung im Code Ã¼ber den Push ins Repository bis hin zum ausgelÃ¶sten Jenkins-Build.  
   Besonders gelungen war, wie er dabei auf potenzielle Fehlerszenarien einging und aufzeigte, wie Jenkins Feedback zu fehlschlagenden Tests oder Build-Konflikten liefert.

4. **Zusammenfassungen nach jedem Abschnitt**  
   Nach jedem Demonstrationsschritt folgte eine prÃ¤gnante Zusammenfassung. Dadurch ermÃ¶glichte Adrian es auch weniger erfahrenen Kommiliton:innen, den roten Faden nicht zu verlieren.  
   Diese Zwischenschritte trugen stark zum Lernerfolg bei.

---

### ğŸ” Fachliche Tiefe & technische Umsetzung

Adrians Vortrag zeichnete sich durch **technische PrÃ¤zision und PraxisnÃ¤he** aus. Die eingesetzten Tools wurden nicht nur korrekt konfiguriert, sondern im Zusammenspiel vorgefÃ¼hrt.  
Er zeigte unter anderem:
- das saubere Triggern der CI-Pipeline nach einem GitHub-Push,
- die Einbindung automatisierter Tests zur QualitÃ¤tskontrolle,
- und die Verifizierung der CodequalitÃ¤t mit SonarQube (optional erwÃ¤hnt).  

Zudem erklÃ¤rte er gut verstÃ¤ndlich, wie **Jenkinsfile-Strukturen** aufgebaut sind, wie die einzelnen Stages (Build, Test, Analyse) ineinandergreifen und wie **Ergebnisse interpretiert** werden.  
Es war erkennbar, dass er sich intensiv mit der Thematik auseinandergesetzt und verschiedene TestlÃ¤ufe im Vorfeld durchgefÃ¼hrt hatte.

---

### ğŸ§  Didaktik & PrÃ¤sentationstechnik

Obwohl Adrian ohne PrÃ¤sentationsfolien arbeitete, war sein Vortrag **klar, ruhig und souverÃ¤n**.  
Besonders hervorzuheben ist seine FÃ¤higkeit, **komplexe AblÃ¤ufe verbal so zu vermitteln, dass auch Nicht-Tech-Expert:innen folgen konnten**.

Er sprach frei, variierte Tempo und Stimme passend zum Inhalt und bezog das Publikum immer wieder mit rhetorischen Fragen ein (â€Was passiert jetzt im Hintergrund?â€œ, â€Woran erkennt man, ob der Build erfolgreich war?â€œ).  
Seine **Zusammenfassungen nach jedem Abschnitt** sowie seine **prÃ¤zisen Live-ErlÃ¤uterungen** machten den Vortrag didaktisch sehr hochwertig.

---

### â­ PersÃ¶nlicher Eindruck & Fazit

Ich war ehrlich gesagt **positiv Ã¼berrascht**, da ich anfangs etwas skeptisch war, als keine klassische PrÃ¤sentation angekÃ¼ndigt wurde. Doch Adrian hat es geschafft, durch eine **konsequent praxisorientierte Live-Demo**, die Erwartungen weit zu Ã¼bertreffen.

Er kombinierte **technisches KÃ¶nnen mit einem didaktisch wertvollen Vortragsstil**, vermittelte Inhalte verstÃ¤ndlich und spannend und zeigte sich in der Fragerunde souverÃ¤n.  
Auch bei potenziellen Fehlerquellen blieb er ruhig und konnte mÃ¶gliche Stolpersteine erklÃ¤ren â€“ das zeugt von echter Sicherheit in der Materie.

**Fazit:**  
Adrian hat eine der besten PrÃ¤sentationen des Kurses gehalten â€“ mit hohem fachlichem Anspruch, sehr guter Struktur und einer angenehmen, klaren Kommunikation. **Chapeau â€“ wirklich stark!**

---


---
